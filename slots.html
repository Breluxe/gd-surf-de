<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Maxi Slots – 5x3 Classic</title>
  <style>
    :root{
      --bg:#07101b;
      --panel:#0f1626;
      --panel-2:#0b1222;
      --accent:#00e5ff;
      --accent-2:#7cff6b;
      --accent-3:#ffdd55;
      --danger:#ff4d6d;
      --text:#e8f1ff;
      --muted:#9bb0d1;
      --win:#8ef06d;
      --shadow: 0 12px 36px rgba(0,0,0,.45), inset 0 0 40px rgba(255,255,255,0.02);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background: radial-gradient(1200px 600px at 50% -15%, #14243a 0%, #07101b 40%, #020511 100%);
      color:var(--text); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; 
      display:flex; align-items:center; justify-content:center; padding:20px;
    }

    /* Main cabinet layout: topbar spans, reels left, controls right */
    .game{
      width:min(1200px, 98vw); min-height:560px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
      border:1px solid rgba(255,255,255,.06); border-radius:20px; box-shadow: var(--shadow);
      overflow:hidden; position:relative; display:grid; grid-template-columns: 1fr 380px; grid-template-rows: auto 1fr; gap:12px;
    }
    .topbar{ grid-column:1 / -1; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 20px; background:linear-gradient(180deg, rgba(0,229,255,0.06), rgba(0,0,0,0)); }

    .logo{display:flex; align-items:center; gap:12px; font-weight:800; letter-spacing:.5px;}
    .logo .spark{font-size:24px; filter:drop-shadow(0 0 8px rgba(255, 221, 85, .9));}
    .badges{display:flex; gap:8px; flex-wrap:wrap}
    .badge{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.03); color:var(--muted); font-size:12px; border:1px solid rgba(255,255,255,.04)}

    /* Reel area becomes a stage inside a slot cabinet */
    .reel-area{
      grid-column: 1 / 2; grid-row: 2 / 3; padding:26px; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(800px 300px at 50% 0%, rgba(0,229,255,.06), transparent 50%), linear-gradient(180deg, rgba(255,255,255,.01), rgba(0,0,0,0));
    }

    .window{
      position:relative; height:420px; width:100%; max-width:820px; overflow:visible; border-radius:18px; border:1px solid rgba(255,255,255,.06);
      background:linear-gradient(180deg, rgba(8,12,20,.85), rgba(6,8,14,.7)); box-shadow: inset 0 8px 30px rgba(0,0,0,.6), 0 18px 40px rgba(0,0,0,.6);
      display:block; padding:18px;
    }

    /* marquee lights using pseudo elements for a cabinet look */
    .window::before{
      content:''; position:absolute; left:10px; right:10px; top:-18px; height:26px; border-radius:14px; background:linear-gradient(90deg,#ffd96a 0%, #ffd96a 2%, transparent 2.5%) repeat-x; background-size:28px 26px; box-shadow:0 6px 24px rgba(255,200,80,.06);
    }
    /* animated cabinet marquee when spinning */
    .window.spinning::before{ animation: marquee 0.9s linear infinite; filter:drop-shadow(0 6px 26px rgba(255,200,80,.25)); }
    @keyframes marquee{ from{ background-position:0 0 } to{ background-position:56px 0 } }
    .window.spinning .symbol{ transform: translateY(-3px) scale(1.03); box-shadow:0 18px 50px rgba(0,0,0,.6); }
    .window::after{
      content:''; position:absolute; left:6px; right:6px; bottom:-12px; height:12px; border-radius:8px; background:linear-gradient(90deg, rgba(0,229,255,.06), rgba(124,255,107,.04)); filter:blur(8px); opacity:.9;
    }

    .grid{position:absolute; inset:18px; border-radius:12px; pointer-events:none}

    .reels{position:relative; display:grid; grid-template-columns: repeat(5, 1fr); gap:12px; padding:8px; height:100%;}

    .reel{position:relative; overflow:hidden; border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.06)); border:1px solid rgba(255,255,255,.04); box-shadow: inset 0 6px 18px rgba(0,0,0,.6);
      transform: translateZ(0);}
    .strip{position:absolute; width:100%; top:0; left:0}

    .symbol{ height:110px; display:flex; align-items:center; justify-content:center; font-size:56px; user-select:none; 
      text-shadow:0 6px 0 rgba(0,0,0,.45), 0 0 32px rgba(255,255,255,.08); background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.02));
      margin:6px; border-radius:10px; color:var(--text);
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .symbol:hover{ transform: translateY(-4px); box-shadow:0 10px 30px rgba(0,0,0,.5)}

    .symbol[data-type="WILD"]{ filter: drop-shadow(0 0 14px rgba(255,221,85,.95)); background:linear-gradient(180deg, rgba(255,236,175,.06), rgba(255,221,85,.03)); }
    .symbol[data-type="SCATTER"]{ filter: drop-shadow(0 0 14px rgba(124,255,107,.95)); background:linear-gradient(180deg, rgba(180,255,200,.03), rgba(124,255,107,.02)); }

    .payline{position:absolute; height:4px; background: linear-gradient(90deg, var(--accent), var(--accent-2)); opacity:.0; transition:opacity .24s ease}
    .payline.active{opacity:.95}

    /* Right side controls as a vertical sidebar */
    .panel{ grid-column: 2 / 3; grid-row: 2 / 3; display:flex; flex-direction:column; gap:12px; padding:18px; align-items:stretch; justify-content:flex-start; background:linear-gradient(180deg, rgba(255,255,255,.00), rgba(0,0,0,0)); }
    .panel .box{background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.04)); border:1px solid rgba(255,255,255,.04); border-radius:14px; padding:14px; box-shadow: var(--shadow)}

    .stat{display:flex; justify-content:space-between; gap:10px; align-items:center; font-weight:800}
    .stat small{color:var(--muted); font-weight:600}

    .controls{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .control{display:flex; align-items:center; gap:8px; background:rgba(255,255,255,.02); border:1px solid rgba(255,255,255,.04); padding:10px 12px; border-radius:12px}
    .control input[type="range"]{width:140px}

    /* Prominent spin button like a cabinet start-button */
    .btn{ border:none; padding:12px 18px; border-radius:12px; cursor:pointer; color:#02121d; font-weight:900; letter-spacing:.6px; box-shadow: 0 10px 30px rgba(0,0,0,.5), inset 0 -3px 0 rgba(0,0,0,.28); transition: transform .06s ease, filter .18s ease, box-shadow .12s ease; background: linear-gradient(180deg, #00e5ff, #00b9d6); }
    .btn:hover{filter:brightness(1.06)}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{ background: linear-gradient(180deg, #7cff6b, #58d84a); box-shadow: 0 10px 30px rgba(80,200,80,.08), inset 0 -3px 0 rgba(0,0,0,.18);}
    .btn.warn{ background: linear-gradient(180deg, #ffdd55, #ffb400); box-shadow: 0 10px 30px rgba(255,200,80,.08), inset 0 -3px 0 rgba(0,0,0,.18);}
    .btn.danger{ background: linear-gradient(180deg, #ff6b8a, #ff3d6e); color:white; box-shadow: 0 10px 30px rgba(255,77,109,.08), inset 0 -3px 0 rgba(0,0,0,.18);}

    /* Big spin button variant */
    #spinBtn{ padding:18px 28px; border-radius:18px; font-size:18px; color:#02121d; background: linear-gradient(180deg,#ffdd55,#ffb400); box-shadow: 0 18px 50px rgba(255,180,50,.12); }
    #spinBtn{ animation: pulse 2.4s ease-in-out infinite; }
    @keyframes pulse{0%{box-shadow:0 18px 50px rgba(255,180,50,.06)}50%{box-shadow:0 26px 80px rgba(255,180,50,.14)}100%{box-shadow:0 18px 50px rgba(255,180,50,.06)}}

    .big-message{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%) scale(.7); font-size:54px; font-weight:900; letter-spacing:1px; opacity:0; pointer-events:none;
      background: linear-gradient(90deg, #fff, #ffdd55, #7cff6b, #00e5ff, #fff); background-clip:text; -webkit-background-clip:text; -webkit-text-fill-color:transparent;
      text-shadow: 0 0 28px rgba(255,255,255,.35); filter:drop-shadow(0 12px 40px rgba(0,229,255,.18))
    }
    .big-message.show{animation: pop 1.2s ease forwards}
    @keyframes pop{0%{opacity:0; transform:translate(-50%,-50%) scale(.6)} 30%{opacity:1; transform:translate(-50%,-50%) scale(1.08)} 60%{transform:translate(-50%,-50%) scale(0.98)} 100%{opacity:1; transform:translate(-50%,-50%) scale(1)} }

    .ticker{position:absolute; left:12px; right:12px; bottom:8px; padding:10px 14px; color:#a7c5ff; background:linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.35)); font-size:12px; border-radius:10px}
    .ticker b{color:#fff}

    .history{max-height:220px; overflow:auto; font-size:13px; line-height:1.5;}
    .history p{margin:6px 0; color:var(--muted)}

    .win-glow{animation: glow 1.2s ease-in-out infinite alternate}
    @keyframes glow{0%{filter:drop-shadow(0 0 0 rgba(255,221,85,0))} 100%{filter:drop-shadow(0 0 24px rgba(255,221,85,0.95))}}

    .toggles{display:flex; gap:10px; flex-wrap:wrap}
    .toggle{display:flex; align-items:center; gap:8px; background:rgba(255,255,255,.02); border:1px solid rgba(255,255,255,.04); padding:8px 10px; border-radius:12px}

    .note{font-size:12px; color:var(--muted)}
    .link{color:var(--accent-2); text-decoration:underline; cursor:pointer}

    @media (max-width: 980px){
      .game{ grid-template-columns: 1fr; grid-template-rows: auto 1fr auto }
      .reel-area{ grid-column:1 / -1 }
      .panel{ grid-column:1 / -1; grid-row:3 / 4 }
      .window{ height:340px }
      .reels{ gap:8px }
      #spinBtn{ width:100% }
    }
  </style>
  
      <div class="box">
        <div class="history" id="history"></div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <dialog id="paytable" style="border:none; border-radius:18px; width:min(760px, 95vw); background:linear-gradient(180deg,#0c1220,#0a0d14); color:#e8f1ff; box-shadow: var(--shadow);">
    <div style="padding:18px 20px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,.08)">
      <h3 style="margin:0">Auszahlungstabelle & Regeln</h3>
      <button id="closePay" class="btn danger">Schließen</button>
    </div>
    <div style="padding:16px 20px; line-height:1.6">
      <p>5 Walzen × 3 Reihen, 10 feste Gewinnlinien (von links nach rechts). <b>WILD (⭐)</b> ersetzt alle Symbole außer <b>SCATTER (🎰)</b>. 3+ SCATTER lösen <b>8 Free Spins</b> aus, Retrigger +5. Scatter zahlt überall.</p>
      <div style="display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:12px; margin-top:10px">
        <div style="background:rgba(255,255,255,.04); padding:10px; border-radius:12px">
          <b>Symbole</b>
          <ul style="margin:6px 0 0 16px">
            <li>🍒 ×5=10 ×4=3 ×3=0.6</li>
            <li>🍋 ×5=8 ×4=2.4 ×3=0.5</li>
            <li>🔔 ×5=12 ×4=4 ×3=1.0</li>
            <li>BAR ×5=16 ×4=6 ×3=1.6</li>
            <li>7️⃣ ×5=40 ×4=10 ×3=2.0</li>
            <li>⭐ (Wild) – ersetzt</li>
            <li>🎰 (Scatter) – 5=15, 4=5, 3=2 + Free Spins</li>
          </ul>
        </div>
        <div style="background:rgba(255,255,255,.04); padding:10px; border-radius:12px">
          <b>Volatilität</b>
          <p>Niedrig = häufige kleine Treffer, Hoch = seltene größere. Beeinflusst die Gewichtung der Walzen.</p>
        </div>
        <div style="background:rgba(255,255,255,.04); padding:10px; border-radius:12px">
          <b>Auto-Play Sicherheit</b>
          <ul style="margin:6px 0 0 16px">
            <li>Stoppt bei Bonus (optional)</li>
            <li>Stop-Loss (Guthaben-Untergrenze)</li>
            <li>Stop bei Einzelgewinn ≥ Limit</li>
          </ul>
        </div>
      </div>
    </div>
  </dialog>

  <audio id="sfx-spin" src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQAAACAA…" preload="auto"></audio>
  <audio id="sfx-win" src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQAAACAA…" preload="auto"></audio>
  <audio id="sfx-big" src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQAAACAA…" preload="auto"></audio>
  <!-- (Hinweis: Dummy-AUDIODaten gekürzt – Sounds werden zur Laufzeit generiert) -->

  <script>
    // ===== Utility =====
    const fmt = (n)=> Number(n).toLocaleString('de-DE',{minimumFractionDigits:2, maximumFractionDigits:2});
    const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

    // ===== Game Data =====
    const ROWS = 3, COLS = 5, LINES = 10;
    const SYMBOLS = [
      { t:'C', label:'🍒', pays:{3:0.6,4:3,5:10}, baseWeight: 36 },
      { t:'L', label:'🍋', pays:{3:0.5,4:2.4,5:8}, baseWeight: 34 },
      { t:'B', label:'🔔', pays:{3:1.0,4:4,5:12}, baseWeight: 22 },
      { t:'R', label:'BAR', pays:{3:1.6,4:6,5:16}, baseWeight: 16 },
      { t:'7', label:'7️⃣', pays:{3:2.0,4:10,5:40}, baseWeight: 9 },
      { t:'W', label:'⭐', pays:{}, baseWeight: 6, wild:true },
      { t:'S', label:'🎰', pays:{3:2,4:5,5:15}, baseWeight: 5, scatter:true }
    ];

    const PAYLINES = [
      [1,1,1], [0,0,0], [2,2,2],
      [0,1,2], [2,1,0],
      [0,0,1], [1,2,2], [2,2,1], [1,0,0], [0,1,2]
    ];

    let state = {
      balance: 1000,
      betPerLine: 0.10,
      freeSpins: 0,
      autoLeft: 0,
      spinning:false,
      turbo:false,
      sound:true,
      stopOnBonus:true,
      volatility:'medium',
      history:[],
      lastWin:0,
    };

  // ===== DOM (will be populated on DOMContentLoaded) =====
  let reelsEl, gridEl, windowEl, balanceEl, lastWinEl, betPerLineEl, totalBetEl, bigMsg, ticker, historyEl;
  let spinBtn, autoBtn, maxBetBtn, betRange, betMinus, betPlus, autoCount, stopLoss, singleWinLimit;
  let turbo, sound, stopOnBonus, volatilitySel, infoBtn, paytableDlg, closePay;

    // ===== Build Reels =====
    function build(){
      reelsEl.innerHTML = '';
      gridEl.innerHTML = '';
      for(let c=0;c<COLS;c++){
        const reel = document.createElement('div');
        reel.className = 'reel';
        const strip = document.createElement('div');
        strip.className='strip';
        reel.appendChild(strip);
        reelsEl.appendChild(reel);
      }
      drawGrid();
      createPaylineOverlays();
      updateUI();
      initialFill();
    }

    function symbolEl(sym){
      const d = document.createElement('div');
      d.className='symbol';
      d.dataset.type = sym.t==='W'?'WILD': sym.t==='S'?'SCATTER': sym.t;
      d.textContent = sym.label;
      return d;
    }

    function initialFill(){
      const strips = [...document.querySelectorAll('.strip')];
      strips.forEach((s)=>{
        s.style.transition='none'; s.style.transform='translateY(0px)'; s.innerHTML='';
        const arr = rngReel(ROWS+8); // overspill for initial look
        arr.forEach(sym=> s.appendChild(symbolEl(sym)));
      });
    }

    function drawGrid(){
      const pad = 16; const cellH = 110, gap=10; const cellW = (reelsEl.clientWidth - (pad*2) - (gap*4)) / 5;
      // Payline overlays created separately.
    }

    function createPaylineOverlays(){
      // remove old
      [...document.querySelectorAll('.payline')].forEach(el=>el.remove());
      const W = reelsEl.clientWidth - 32; const H = 380 - 32; // approx inner window
      const colW = W / COLS; const rowH = (H - 40)/ROWS; // rough fit
      PAYLINES.forEach((line, idx)=>{
        const el = document.createElement('div'); el.className='payline'; el.id = 'line-'+idx;
        const y1 = 16 + 55 + line[0]* (rowH+10);
        const y5 = 16 + 55 + line[2]* (rowH+10);
        el.style.left = '16px'; el.style.right='16px'; el.style.top = y1+'px'; el.style.height='3px';
        document.querySelector('.window').appendChild(el);
      });
    }

    // ===== RNG / Weights =====
    function weightedTable(vol){
      const mult = {low:1.2, medium:1, high:0.85}[vol];
      return SYMBOLS.map(s=> ({...s, weight: Math.max(1, Math.round((s.baseWeight) * (s.scatter||s.wild ? mult*0.8 : mult)))}));
    }

    function rngReel(n){
      const table = weightedTable(state.volatility);
      const pool = [];
      table.forEach(s=>{ for(let i=0;i<s.weight;i++) pool.push(s); });
      const out = [];
      for(let i=0;i<n;i++) out.push(pool[(Math.random()*pool.length)|0]);
      return out;
    }

    async function spin(){
      if(state.spinning) return;
      const totalBet = state.freeSpins>0 ? 0 : state.betPerLine * LINES;
      if(state.balance < totalBet){ note(`Nicht genug Guthaben für Einsatz ${fmt(totalBet)}.`); return; }

      state.spinning = true; toggleButtons();
  windowEl.classList.add('spinning');
      state.lastWin = 0; lastWinEl.textContent = fmt(0);

      if(state.freeSpins<=0){
        state.balance -= totalBet; animateBalance();
      } else {
        note(`Free Spin aktiv (${state.freeSpins} verbleibend)`);
      }

      if(state.sound) playBeep(180, 0.08);

      const results = [];
      const strips = [...document.querySelectorAll('.strip')];
      const stopDelay = state.turbo? 80 : 280;

      for(let c=0;c<COLS;c++){
        const strip = strips[c];
        const spinLen = (state.turbo? 12: 22) + (c*3);
        const seq = rngReel(spinLen);
        // ensure at least ROWS on end are our final symbols
        const final3 = rngReel(ROWS);
        results[c] = final3;
        const all = seq.concat(final3);

        // build visuals
        strip.innerHTML='';
        all.forEach(sym=> strip.appendChild(symbolEl(sym)));
        const totalH = all.length * 110;
        strip.style.transition = 'transform '+ (state.turbo? .35:.8) +'s cubic-bezier(.2,.8,.1,1)';
        strip.style.transform = `translateY(-${totalH - (ROWS*110)}px)`;

        await sleep(stopDelay);
      }

      // Wait for last transition end
      await sleep(state.turbo? 380: 900);

      const matrix = toMatrix(results);
      const outcome = evaluate(matrix);
      state.lastWin = outcome.totalWin;
      state.balance += outcome.totalWin;
      animateBalance();
      lastWinEl.textContent = fmt(outcome.totalWin);

      highlightWins(outcome.hits);

      if(outcome.freeSpinsAward>0){
        state.freeSpins += outcome.freeSpinsAward;
        flashMsg(`+${outcome.freeSpinsAward} FREE SPINS!`);
        if(state.stopOnBonus && state.autoLeft>0) state.autoLeft = 0; // stop autoplay on bonus
      }

      if(outcome.totalWin >= (Number(singleWinLimit.value)||Infinity)){
        note(`Auto-Play gestoppt: Einzelgewinnlimit erreicht (${fmt(outcome.totalWin)}).`);
        state.autoLeft = 0;
      }

      updateHistory(matrix, outcome);

      state.spinning = false; toggleButtons();
  windowEl.classList.remove('spinning');

      // Autoplay loop
      if(state.autoLeft>0){
        const sl = Number(stopLoss.value||0);
        if(sl>0 && state.balance <= sl){ note(`Auto-Play gestoppt: Stop-Loss ${fmt(sl)}.`); state.autoLeft = 0; return; }
        state.autoLeft--; autoCount.value = String(state.autoLeft);
        await sleep(state.turbo? 200: 700);
        spin();
      }
    }

    function toMatrix(results){
      // results[col][row]
      const m = Array.from({length:ROWS}, ()=> Array(COLS).fill(null));
      for(let c=0;c<COLS;c++){
        for(let r=0;r<ROWS;r++) m[r][c] = results[c][r];
      }
      return m; // m[row][col]
    }

    function matchOnLine(m, line){
      // From left to right, count matching considering wilds; ignore scatter here
      const get = (r,c)=> m[r][c];
      // Find base symbol type on first reel (not wild, not scatter)
      let base = null;
      for(let c=0;c<COLS;c++){
        const sym = get(line[c]||line[0], c);
        if(!sym.wild && !sym.scatter){ base = sym.t; break; }
        if(sym.scatter) break; // can't start with scatter on paylines
      }
      if(!base) base = 'W'; // all wilds

      let count = 0; const coords=[]; let broken=false;
      for(let c=0;c<COLS;c++){
        const sym = get(line[c]||line[0], c);
        if(sym.scatter){ broken=true; break; }
        if(sym.t===base || sym.wild || base==='W') { count++; coords.push([line[c]||0, c]); }
        else break;
      }
      return {base, count, coords};
    }

    function evaluate(m){
      let total = 0; const hits=[]; let freeSpinsAward=0;
      // Scatter count
      let scatters=0; const scatterCoords=[];
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ if(m[r][c].scatter){ scatters++; scatterCoords.push([r,c]); } }
      if(scatters>=3){
        freeSpinsAward = 8 + (scatters-3)*2; // 3→8, 4→10, 5→12
        total += SYMBOLS.find(s=>s.t==='S').pays[scatters] * state.betPerLine; // scatter pays on total bet unit-ish
        hits.push({type:'scatter', coords: scatterCoords});
      }

      // Paylines
      PAYLINES.forEach((line, idx)=>{
        const {base, count, coords} = matchOnLine(m, line);
        if(count>=3){
          const sym = base==='W' ? SYMBOLS.find(s=>s.t==='7') : SYMBOLS.find(s=>s.t===base);
          const pay = (sym.pays[count]||0) * state.betPerLine;
          if(pay>0){ total += pay; hits.push({type:'line', line:idx, coords, pay, base}); }
        }
      });

      // Free spins multiplier (simple): during FS, 2× wins
      if(state.freeSpins>0) total *= 2;

      // Big win feedback
      if(total >= (state.betPerLine*LINES)*10){ flashMsg('MEGA WIN!'); if(state.sound) playJingle(); }
      else if(total >= (state.betPerLine*LINES)*5){ flashMsg('BIG WIN!'); if(state.sound) playBeep(880, .2); }

      // decrement free spins if active
      if(state.freeSpins>0) state.freeSpins--;

      return { totalWin: Number(total.toFixed(2)), hits, freeSpinsAward };
    }

    function highlightWins(hits){
      // Clear any existing highlights
      document.querySelectorAll('.symbol').forEach(el=> el.classList.remove('win-glow'));
      document.querySelectorAll('.payline').forEach(el=> el.classList.remove('active'));

      hits.forEach(h=>{
        h.coords.forEach(([r,c])=>{
          const strip = document.querySelectorAll('.strip')[c];
          const symEl = strip.children[strip.children.length - ROWS + r];
          if(symEl) symEl.classList.add('win-glow');
        });
        if(h.type==='line' && typeof h.line==='number'){
          const lineEl = document.getElementById('line-'+h.line); if(lineEl) lineEl.classList.add('active');
          note(`Linie ${h.line+1}: Gewinn ${fmt(h.pay)}`);
        }
        if(h.type==='scatter') note(`Scatter: ${h.coords.length}x – Free Spins & Gewinn!`);
      });
    }

    function updateHistory(m, outcome){
      const txt = `Spin – Einsatz ${fmt(state.freeSpins>0?0:state.betPerLine*LINES)} | Gewinn ${fmt(outcome.totalWin)}${state.freeSpins>0?' (Free Spin x2 Multiplier)':''}`;
      state.history.unshift(txt);
      state.history = state.history.slice(0, 50);
      renderHistory();
    }

    function renderHistory(){
      historyEl.innerHTML = state.history.map(p=>`<p>• ${p}</p>`).join('');
      historyEl.scrollTop = 0;
    }

    function updateUI(){
      balanceEl.textContent = fmt(state.balance);
      betPerLineEl.textContent = state.betPerLine.toFixed(2);
      totalBetEl.textContent = fmt(state.betPerLine*LINES);
    }

    function animateBalance(){
      const start = Number(balanceEl.textContent.replace(/[^0-9,.-]/g,'').replace('.', '').replace(',', '.'))||state.balance;
      const end = state.balance; const dur=420; const t0=performance.now();
      function step(t){ const k=Math.min(1,(t-t0)/dur); balanceEl.textContent = fmt(start + (end-start)*k); if(k<1) requestAnimationFrame(step)}
      requestAnimationFrame(step);
    }

    function note(t){ ticker.innerHTML = t; }
    function flashMsg(t){ bigMsg.textContent=t; bigMsg.classList.remove('show'); void bigMsg.offsetWidth; bigMsg.classList.add('show'); setTimeout(()=>bigMsg.classList.remove('show'), 1400); }

    function toggleButtons(){
      spinBtn.disabled = state.spinning; autoBtn.disabled = state.spinning;
    }

    // ===== Sounds (synth via WebAudio for offline) =====
    let audioCtx = null;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function playBeep(freq=440, dur=0.12){ if(!state.sound) return; ensureAudio(); const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.frequency.value=freq; o.type='triangle'; g.gain.setValueAtTime(.0001, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(.08, audioCtx.currentTime+.02); g.gain.exponentialRampToValueAtTime(.0001, audioCtx.currentTime+dur); o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur+.05); }
    function playJingle(){ if(!state.sound) return; ensureAudio(); const seq=[440,660,880,990,1320]; let t=0; seq.forEach(f=>{ setTimeout(()=>playBeep(f, .12), t); t+=120; }); }

    // Wire DOM + events after page is ready to avoid null references
    document.addEventListener('DOMContentLoaded', ()=>{
      reelsEl = document.getElementById('reels');
      gridEl = document.getElementById('grid');
      windowEl = document.querySelector('.window');
      balanceEl = document.getElementById('balance');
      lastWinEl = document.getElementById('lastWin');
      betPerLineEl = document.getElementById('betPerLine');
      totalBetEl = document.getElementById('totalBet');
      bigMsg = document.getElementById('bigMsg');
      ticker = document.getElementById('ticker');
      historyEl = document.getElementById('history');

      spinBtn = document.getElementById('spinBtn');
      autoBtn = document.getElementById('autoBtn');
      maxBetBtn = document.getElementById('maxBetBtn');

      betRange = document.getElementById('betRange');
      betMinus = document.getElementById('betMinus');
      betPlus = document.getElementById('betPlus');

      autoCount = document.getElementById('autoCount');
      stopLoss = document.getElementById('stopLoss');
      singleWinLimit = document.getElementById('singleWinLimit');

      turbo = document.getElementById('turbo');
      sound = document.getElementById('sound');
      stopOnBonus = document.getElementById('stopOnBonus');
      volatilitySel = document.getElementById('volatility');

      infoBtn = document.getElementById('infoBtn');
      paytableDlg = document.getElementById('paytable');
      closePay = document.getElementById('closePay');

      // Event bindings
      spinBtn.addEventListener('click', ()=>{ if(state.autoLeft>0){ state.autoLeft=0; autoCount.value='0'; } spin(); });
      autoBtn.addEventListener('click', ()=>{ state.autoLeft = Number(autoCount.value||0); if(state.autoLeft>0) spin(); });
      maxBetBtn.addEventListener('click', ()=>{ betRange.value=20; applyBet(); });

      betRange.addEventListener('input', applyBet);
      betMinus.addEventListener('click', ()=>{ betRange.value = Math.max(1, Number(betRange.value)-1); applyBet(); });
      betPlus.addEventListener('click', ()=>{ betRange.value = Math.min(20, Number(betRange.value)+1); applyBet(); });

      function applyBet(){
        const steps = [0.05,0.10,0.20,0.30,0.40,0.50,0.60,0.80,1.00,1.20,1.50,1.80,2.00,2.50,3.00,4.00,5.00,7.50,10.00,20.00];
        state.betPerLine = steps[Number(betRange.value)-1];
        updateUI();
      }

      turbo.addEventListener('change', ()=> state.turbo = turbo.checked);
      sound.addEventListener('change', ()=> state.sound = sound.checked);
      stopOnBonus.addEventListener('change', ()=> state.stopOnBonus = stopOnBonus.checked);
      volatilitySel.addEventListener('change', ()=> state.volatility = volatilitySel.value);

      infoBtn.addEventListener('click', ()=> paytableDlg.showModal());
      closePay.addEventListener('click', ()=> paytableDlg.close());

      window.addEventListener('resize', ()=>{ createPaylineOverlays(); });

      // Start the UI
      build();
    });
  </script>
</body>
</html>
